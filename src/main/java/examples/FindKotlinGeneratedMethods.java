package examples;

import kotlinx.metadata.*;
import kotlinx.metadata.jvm.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.stream.Collectors;

/**
 * This class uses kotlinx-metadata-jvm and ASM to load JVM signatures of methods in the Kotlin .class file, that are
 * automatically generated by the Kotlin compiler. Such methods do not have any source representation and thus do not
 * have a line number table, which makes code coverage tools treat them as non-covered in any execution of the program.
 *
 * For more information, see https://youtrack.jetbrains.com/issue/KT-18383
 */
public class FindKotlinGeneratedMethods {
    /**
     * @param bytes array containing the bytes of the .class file
     * @return list of JVM signatures of methods, automatically generated by the Kotlin compiler,
     *         for example: `equals(Ljava/lang/Object;)Z`
     */
    @NotNull
    public static List<String> run(@NotNull byte[] bytes) {
        // First, load the @kotlin.Metadata annotation
        AnnotationNode annotationNode = loadKotlinMetadataAnnotationNode(bytes);
        if (annotationNode == null) {
            throw new IllegalArgumentException("Not a Kotlin .class file! No @kotlin.Metadata annotation found");
        }

        // Then convert it to KotlinClassHeader
        KotlinClassHeader header = createHeader(annotationNode);

        // Read and parse the metadata
        KotlinClassMetadata metadata = KotlinClassMetadata.read(header);

        // The given .class file could have been either a normal Kotlin class, or a file facade (a .class file
        // generated for top-level functions/properties in one source file).
        // Since the metadata is represented a bit differently in these cases, we need to handle them separately
        List<JvmMethodSignature> result;
        if (metadata instanceof KotlinClassMetadata.Class) {
            result = loadMethodsFromClass((KotlinClassMetadata.Class) metadata);
        } else if (metadata instanceof KotlinClassMetadata.FileFacade) {
            result = loadMethodsFromFileFacade((KotlinClassMetadata.FileFacade) metadata);
        } else if (metadata instanceof KotlinClassMetadata.MultiFileClassPart) {
            result = loadMethodsFromMultiFileClassPart((KotlinClassMetadata.MultiFileClassPart) metadata);
        } else {
            result = Collections.emptyList();
        }

        // Transform each JVM method signature to a simple string, concatenating the name and the method descriptor
        return result.stream().map(JvmMethodSignature::asString).collect(Collectors.toList());
    }

    /**
     * Loads the AnnotationNode corresponding to the @kotlin.Metadata annotation on the .class file,
     * or returns null if there's no such annotation.
     */
    @Nullable
    private static AnnotationNode loadKotlinMetadataAnnotationNode(byte[] bytes) {
        ClassNode node = new ClassNode();
        new ClassReader(bytes).accept(node, Opcodes.V1_8);
        return node.visibleAnnotations.stream()
                .filter(it -> "Lkotlin/Metadata;".equals(it.desc))
                .findFirst()
                .orElse(null);
    }

    /**
     * Converts the given AnnotationNode representing the @kotlin.Metadata annotation into KotlinClassHeader,
     * to be able to use it in KotlinClassMetadata.read.
     */
    @NotNull
    private static KotlinClassHeader createHeader(AnnotationNode node) {
        Integer kind = null;
        int[] metadataVersion = null;
        int[] bytecodeVersion = null;
        String[] data1 = null;
        String[] data2 = null;
        String extraString = null;
        String packageName = null;
        Integer extraInt = null;

        Iterator<Object> it = node.values.iterator();
        while (it.hasNext()) {
            String name = (String) it.next();
            Object value = it.next();

            switch (name) {
                case "k": kind = (Integer) value; break;
                case "mv": metadataVersion = listToIntArray(value); break;
                case "bv": bytecodeVersion = listToIntArray(value); break;
                case "d1": data1 = listToStringArray(value); break;
                case "d2": data2 = listToStringArray(value); break;
                case "xs": extraString = (String) value; break;
                case "pn": packageName = (String) value; break;
                case "xi": extraInt = (Integer) value; break;
            }
        }

        return new KotlinClassHeader(
                kind, metadataVersion, bytecodeVersion, data1, data2, extraString, packageName, extraInt
        );
    }

    @SuppressWarnings("unchecked")
    private static int[] listToIntArray(Object list) {
        return ((List<Integer>) list).stream().mapToInt(it -> it).toArray();
    }

    @SuppressWarnings("unchecked")
    private static String[] listToStringArray(Object list) {
        return ((List<String>) list).toArray(new String[0]);
    }

    /**
     * Visits the metadata of a class and returns the list of JVM method signatures of generated methods there.
     */
    @NotNull
    private static List<JvmMethodSignature> loadMethodsFromClass(KotlinClassMetadata.Class metadata) {
        List<JvmMethodSignature> result = new ArrayList<>();
        metadata.accept(new KmClassVisitor() {
            @Override
            public KmFunctionVisitor visitFunction(int flags, String name) {
                return createFunctionVisitor(flags, result);
            }

            @Override
            public KmPropertyVisitor visitProperty(int flags, String name, int getterFlags, int setterFlags) {
                return createPropertyVisitor(getterFlags, setterFlags, result);
            }
        });
        return result;
    }

    /**
     * Visits the metadata of a file facade and returns the list of JVM method signatures of generated methods there.
     */
    @NotNull
    private static List<JvmMethodSignature> loadMethodsFromFileFacade(KotlinClassMetadata.FileFacade metadata) {
        List<JvmMethodSignature> result = new ArrayList<>();
        metadata.accept(createPackageVisitor(result));
        return result;
    }

    /**
     * Visits the metadata of a multi-file class part (a file facade annotated with @file:JvmMultifileClass)
     * and returns the list of JVM method signatures of generated methods there.
     */
    @NotNull
    private static List<JvmMethodSignature> loadMethodsFromMultiFileClassPart(KotlinClassMetadata.MultiFileClassPart metadata) {
        List<JvmMethodSignature> result = new ArrayList<>();
        metadata.accept(createPackageVisitor(result));
        return result;
    }

    /**
     * Creates a common visitor for {@link #loadMethodsFromFileFacade(KotlinClassMetadata.FileFacade)} and
     * {@link #loadMethodsFromMultiFileClassPart(KotlinClassMetadata.MultiFileClassPart)}.
     */
    @NotNull
    private static KmPackageVisitor createPackageVisitor(List<JvmMethodSignature> result) {
        return new KmPackageVisitor() {
            @Override
            public KmFunctionVisitor visitFunction(int flags, String name) {
                return createFunctionVisitor(flags, result);
            }

            @Override
            public KmPropertyVisitor visitProperty(int flags, String name, int getterFlags, int setterFlags) {
                return createPropertyVisitor(getterFlags, setterFlags, result);
            }
        };
    }

    /**
     * Creates a common function visitor that dumps the JVM signatures of generated methods into the given list.
     *
     * Currently, it handles those methods that are marked as "synthesized" in the Kotlin metadata
     * (see {@link Flag.Function#IS_SYNTHESIZED}), which include:
     * <ul>
     *   <li>methods for data classes: componentN, copy, equals, hashCode, toString</li>
     *   <li>values/valueOf methods for enum classes</li>
     *   <li>box/unbox methods for inline classes</li>
     * </ul>
     */
    @Nullable
    private static KmFunctionVisitor createFunctionVisitor(int flags, List<JvmMethodSignature> result) {
        // Filter out non-synthesized functions
        if (!Flag.Function.IS_SYNTHESIZED.invoke(flags)) return null;

        return new KmFunctionVisitor() {
            @Override
            public KmFunctionExtensionVisitor visitExtensions(KmExtensionType type) {
                return new JvmFunctionExtensionVisitor() {
                    @Override
                    public void visit(JvmMethodSignature desc) {
                        if (desc != null) {
                            result.add(desc);
                        }
                    }
                };
            }
        };
    }

    /**
     * Creates a common property visitor that dumps the JVM signatures of all accessors whose bodies are generated
     * by the Kotlin compiler automatically into the given list.
     *
     * For example, in the following Kotlin code:
     * <pre>
     *     var name: String
     *         get() = field
     * </pre>
     *
     * The property `name` has both a getter and a setter, but only the setter body is generated by default by the
     * Kotlin compiler. Therefore, this method will return the list consisting of a single element
     * {@code "setName(Ljava/lang/String;)V"}.
     */
    @NotNull
    private static KmPropertyVisitor createPropertyVisitor(int getterFlags, int setterFlags, List<JvmMethodSignature> result) {
        return new KmPropertyVisitor() {
            @Override
            public KmPropertyExtensionVisitor visitExtensions(KmExtensionType type) {
                return new JvmPropertyExtensionVisitor() {
                    @Override
                    public void visit(JvmFieldSignature fieldDesc, JvmMethodSignature getterDesc, JvmMethodSignature setterDesc) {
                        if (getterDesc != null && !Flag.PropertyAccessor.IS_NOT_DEFAULT.invoke(getterFlags)) {
                            result.add(getterDesc);
                        }
                        if (setterDesc != null && !Flag.PropertyAccessor.IS_NOT_DEFAULT.invoke(setterFlags)) {
                            result.add(setterDesc);
                        }
                    }
                };
            }
        };
    }
}
